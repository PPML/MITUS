#' THIS FUNCTION INPUTS A TABLE OF PARAMETERS AND RUNS THE TB MODEL
#' AND GENERATES AN ARRAY OF OUTPUTS
#'@name  national_OutputsZint
#'@param samp_i which row of the parameter matrix to use
#'@param ParMatrix parameter matrix to use in the simulation
#'@param loc two-digit abbreviation for location
#'@param output_month when to output results
#'@param startyr year to start the simulation
#'@param endyr year to end the simulation
#'@param Int1 boolean for intervention 1
#'@param Int2 boolean for intervention 2
#'@param Int3 boolean for intervention 3
#'@param Int4 boolean for intervention 4
#'@param Int5 boolean for intervention 5
#'@param Scen1 boolean for scenario 1
#'@param Scen2 boolean for scenario 2
#'@param Scen3 boolean for scenario 3
#'@param Scen4 boolean for scenario 4
#'@param Scen5 boolean for scenario 3
#'@param Scen6 boolean for scenario 4
#'@param prg_chng vector of program change values
#'@param ttt_list list of targeted testing and treatment values
#'@param par2020 vector of 2020 adjustment parameters
#'@param care_cascade list of parameters for changes to LTBI care cascade
#'@param return_params list of parameters to govern the transition to post-COVID param levels
#'@return results data frame of output
#'@export
national_OutputsZint <-  function(samp_i=1,ParMatrix,loc, output_month=11, startyr=1950, endyr=2050,
                                  Int1=0,Int2=0,Int3=0,Int4=0,Int5=0,
                                  Scen1=0,Scen2=0,Scen3=0,Scen4=0,Scen5=0,Scen6=0,
                                  prg_chng=def_prgchng(Par[1,]), ttt_list=list(def_ttt_nat_ag()),
                                  care_cascade = def_care_cascade(),
                                  par2020 = parCOVID,
                                  return_params = def_returnScenario()
                                  ) {
  # format parameter vector
  if(min(dim(as.data.frame(ParMatrix)))==1) {
    Par1 <- as.numeric(ParMatrix);
    names(Par1) <- names(ParMatrix)
  } else {  Par1 <- as.numeric(ParMatrix[samp_i,]);
  names(Par1) <- colnames(ParMatrix) }

  # assign the parameter vector to P
  P <- Par1

  # set any pre-defined interventions or scenario variables passed in
  Int1 <<- Int1;
  Int2 <<- Int2;
  Int3 <<- Int3;
  Int4 <<- Int4;
  Int5 <<- Int5;
  Scen1 <<- Scen1;
  Scen2 <<- Scen2;
  Scen3 <<- Scen3;
  Scen4 <<- Scen4;
  Scen5 <<- Scen5;
  Scen6 <<- Scen6;
  # call the parameter formatting function
  prms <- list()

  # print(par2020[1:6])
  prms <- national_param_init(P = P,
                              loc = loc,
                              Int1 = Int1,
                              Int2 = Int2,
                              Int3 = Int3,
                              Int4 = Int4,
                              Int5 = Int5,
                              Scen1 = Scen1,Scen2 = Scen2,Scen3 = Scen3,
                              prg_chng = prg_chng, ttt_list = ttt_list, immig2020Vec = par2020[1:6])

  ### add in the 2020 parameter adjustments
  unadj_prms <- readRDS(system.file("US/basecaseParams.rds", package="MITUS"))

  prms$ImmAct[889:1801,] <- unadj_prms$ImmAct[889:1801,]
  prms$ImmFst[889:1801,] <- unadj_prms$ImmFst[889:1801,]
  prms$ImmLat[889:1801,] <- unadj_prms$ImmLat[889:1801,]
  prms$ImmNon[889:1801,] <- unadj_prms$ImmNon[889:1801,]

  # ifelse  ( prms$ImmAct[889:1801,] == unadj_prms$ImmAct[889:1801,], print("Success"), print("Failed"))

  prms$ImmAct[1:842,] <- unadj_prms$ImmAct[1:842,]
  prms$ImmFst[1:842,] <- unadj_prms$ImmFst[1:842,]
  prms$ImmLat[1:842,] <- unadj_prms$ImmLat[1:842,]
  prms$ImmNon[1:842,] <- unadj_prms$ImmNon[1:842,]

  # ifelse  ( prms$ImmAct[1:842,] == unadj_prms$ImmAct[1:842,], print("Success"), print("Failed"))

  ### adjust parameters for 2020 ###
  names(par2020) <-  c("ImmigKnot1", "ImmigKnot2", "ImmigKnot3", "ImmigKnot4", "ImmigKnot5", "ImmigKnot6",
                       "DxtKnot1", "DxtKnot2", "DxtKnot3", "DxtKnot4", "DxtKnot5", "DxtKnot6",
                       "TransKnot1", "TransKnot2", "TransKnot3", "TransKnot4", "TransKnot5", "TransKnot6",
                       "CaseFatKnot1", "CaseFatKnot2", "CaseFatKnot3", "CaseFatKnot4", "CaseFatKnot5", "CaseFatKnot6")
  prms2020 <- adj_param_2020(rDxt = prms$rDxt,
                             NixTrans = prms$NixTrans,
                             par2020 = par2020,
                             return_params = return_params)
  # call our rebalancing function
  trans_mat_tot_ages<<-reblncd(mubt = prms$mubt,can_go = can_go,RRmuHR = prms$RRmuHR[2], RRmuRF = prms$RRmuRF, HRdist = HRdist, dist_gen_v=dist_gen_v, adj_fact=prms[["adj_fact"]])
  if(any(trans_mat_tot_ages>1)) print("transition probabilities are too high")

  # create a vector of setup parameters
  setup <- c(endyr-(startyr-1), length(func_ResNam()), output_month)

  # call the model
  m <- national_cSim( setup_pars = setup               , rDxt         = prms[["rDxt"]]        , TxQualt       = prms[["TxQualt"]]     , InitPop      = prms[["InitPop"]]     , Mpfast   = prms[["Mpfast"]]   ,
                      ExogInf    = prms[["ExogInf"]]   , MpfastPI     = prms[["MpfastPI"]]    , Mrslow        = prms[["Mrslow"]]      , rrSlowFB     = prms[["rrSlowFB"]]    ,
                      rfast      = prms[["rfast"]]     , RRcurDef     = prms[["RRcurDef"]]    , rSlfCur       = prms[["rSlfCur"]]     , p_HR         = prms[["p_HR"]]        , vTMort        = prms[["vTMort"]],
                      RRmuRF     = prms[["RRmuRF"]]    , RRmuHR       = prms[["RRmuHR"]]      , Birthst       = prms[["Birthst"]]     , HrEntEx      = prms[["HrEntEx"]]     , ImmNon        = prms[["ImmNon"]],
                      ImmLat     = prms[["ImmLat"]]    , ImmAct       = prms[["ImmAct"]]      , ImmFst        = prms[["ImmFst"]]      , Int1Test     = prms[['Int1Test']]    , Int1Init     = prms[["Int1Init"]],
                      Int1Tx     = prms[['Int1Tx']]    , net_mig_usb  = prms[["net_mig_usb"]] , net_mig_nusb  = prms[["net_mig_nusb"]], RRmuTBPand   = prms2020[["RRmuTBPand"]] , SpImmNon     = prms[["SpImmNon"]],
                      mubt       = prms[["mubt"]]      , RelInf       = prms[["RelInf"]]      , RelInfRg      = prms[["RelInfRg"]]    , RRcrAG       = prms[["RRcrAG"]]      , Vmix          = prms[["Vmix"]],
                      rEmmigFB   = prms [["rEmmigFB"]] , TxVec        = prms[["TxVec"]]       , TunTxMort     = prms[["TunTxMort"]]   , rDeft        = prms[["rDeft"]]       , ttt_samp_dist = prms[["ttt_sampling_dist"]],
                      #ttt_ag     = prms[["ttt_ag"]]    , ttt_na       = prms[["ttt_na"]]      ,
                      ttt_month     = prms[["ttt_month"]]   , ttt_pop_scrn = prms[["ttt_pop_scrn"]], ttt_ltbi      = prms[["ttt_ltbi"]],
                      LtTxPar    = prms[["LtTxPar"]]   , LtDxPar_lt   = prms[["LtDxPar_lt"]]  , LtDxPar_nolt  = prms[["LtDxPar_nolt"]], rrTestLrNoTb = prms[["rrTestLrNoTb"]], rrTestHr = prms[["rrTestHr"]],
                      rLtScrt    = prms[["rLtScrt"]]   , RRdxAge      = prms[["RRdxAge"]]     , ttt_ltbi_init = as.numeric(care_cascade["ttt_ltbi_init"])       , ttt_ltbi_comp = as.numeric(care_cascade["ttt_ltbi_comp"]), ttt_ltbi_eff  = as.numeric(care_cascade["ttt_ltbi_eff"]),
                      ttt_ltbi_sens = as.vector(unlist(care_cascade["ttt_ltbi_sens"]))  , ttt_ltbi_spec = as.vector(unlist(care_cascade["ttt_ltbi_spec"]))      , ttt_ltbi_accept = as.numeric(care_cascade["ttt_ltbi_accept"])     , rRecov       = prms[["rRecov"]]      , pImmScen   = prms[["pImmScen"]],
                      EarlyTrend = prms[["EarlyTrend"]], pReTx        = prms[["pReTx"]]       , ag_den        = prms[["aging_denom"]] , NixTrans     = prms[["NixTrans"]]    , NixTb = prms[["NixTb"]],
                      dist_gen   = prms[["dist_gen"]]  , trans_mat_tot_ages = trans_mat_tot_ages)$Outputs
  # print(dim(m))
  colnames(m) <- func_ResNam();
  results<<-as.matrix(m)

  return(results)
}


#'wrapper function for the above function
#'@name  national_OutputsInt
#'@param loc two-digit abbreviation for location
#'@param ParMatrix parameters to use in the simulation
#'@param n_cores how many cores to use
#'@param endyr year to end the simulation
#'@param startyr year to start the simulation
#'@param Int1 boolean for intervention 1
#'@param Int2 boolean for intervention 2
#'@param Int3 boolean for intervention 3
#'@param Int4 boolean for intervention 4
#'@param Int5 boolean for intervention 5
#'@param Scen1 boolean for scenario 1
#'@param Scen2 boolean for scenario 2
#'@param Scen3 boolean for scenario 3
#'@param prg_chng vector of program change values
#'@param ttt_list list of targeted testing and treatment values
#'@return out outputs
#'@export
national_OutputsInt <- function(loc,ParMatrix,n_cores=1,startyr=1950, endyr=2050,Int1=0,Int2=0,Int3=0,Int4=0,Int5=0,Scen1=0,Scen2=0,Scen3=0,prg_chng, ttt_list, care_cascade, par2020=c(rep(0,18),rep(1,6))) {
  if(min(dim(as.data.frame(ParMatrix)))==1) {
    out <- national_OutputsZint(samp_i=1,ParMatrix=ParMatrix,loc=loc,endyr=endyr,Int1=Int1,Int2=Int2,Int3=Int3,Int4=Int4,Int5=Int5,Scen1=Scen1,Scen2=Scen2,Scen3=Scen3, prg_chng=prg_chng, ttt_list=ttt_list, care_cascade = care_cascade)
  } else {
    out0 <- mclapply(X=1:nrow(ParMatrix),FUN=national_OutputsZint,mc.cores=n_cores,
                     ParMatrix=ParMatrix, loc=loc,endyr=endyr,Int1=Int1,Int2=Int2,Int3=Int3,Int4=Int4,Int5=Int5,Scen1=Scen1,Scen2=Scen2,Scen3=Scen3,prg_chng=prg_chng,ttt_list= ttt_list, care_cascade=care_cascade)

    out <- array(NA,dim=c(length(out0),endyr-(startyr-1),length(func_ResNam())))

    for(i in 1:length(out0)){
      out[i,,] <- as.matrix(out0[[i]])
    }
    dimnames(out)[[3]]<-func_ResNam()
  }
  if (sum(Int1,Int2,Int3,Int4,Int5,Scen1,Scen2,Scen3)==0) intv<-1;
  if(Int1==1) intv<-2;if(Int2==1) intv<-3; if(Int3==1) intv<-4;
  if(Int4==1) intv<-5; if(Int5==1) intv<-6; if(Scen1==1) intv<-7;
  if(Scen2==1) intv<-8;if(Scen3==1) intv<-9;
  # saveRDS(out, file=paste("~MITUS/",loc,"_results_",intv,".rds",sep=""))
  # save(out,file=paste("/Users/nis100/MITUS/",loc,"_results_",intv,".rda",sep=""))
  return(out)
}
